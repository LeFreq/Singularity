This is a project for the OS CONVERGENCE, where OSs figure out they're all trying to accomplish the same thing.  It emerged out of the conflict between proprietary and free software over which is best.  We'll combine the best practices of each and add totally NEW computer science.  There's no compiler.  Parametized object macros are built that turn into machine code on-the-fly.  Here's another preview:  good architecture reduces code size and complexity by 100 log2(LOC).  OOP was the best architectural aid that CS had up to this point, but this project takes a systems-level approach and rearchitects the whole software environment, optimizing all OS-APP-HARDWARE questions into new efficiencies never conceived or attained before.  That equation will make apps 10K instead of 100M because of radical and pervasive re-useability.  Meditate on it.

Position creates a new OS starting from basic principles of OS theory, modular and object-oriented, and at the bare metal (the CPU architecture).  It comes out of frustration of the bloatware that all modern OSs have become and new wisdom about system architecture via epistemology (see Zen Code on the Pangaia wiki).  With no thanks to artificially cheap manufacturing prices and other voodoo, this project is made also to fix the instabilities that have cropped up from poor or inadequate design choices from legacy systems, including Intel, X, Microsoft, and Unix.  But we're not just going to scratch an itch, we're going to ADVANCE Computer Science and Philosophy.  Woot!

The name Position is a spin on POSIX.  The idea of PositionOS is Portability to the MAX, an end-point to those design goals.  See Samurai Jack (Pangaia wiki) for his contributions to these project ideas.  It is also architected like the human mind:  built from simple primitives towards higher levels of abstraction.

Core philosophies:
1. There are *two core relationships* to the machine as far as software and the OS are concerned:  application user and data administrator, much like CODE vs. DATA.  Hiding this from the user makes either users or developers dumb. (-ChromeOS/Surface/Windows10)
2. One can get better performance by using *better hardware and software archictecture* rather than requiring MORE hardware. (-Linux/Microsoft/Apple)
3. All data relate to other data (wikiwikiweb), so *make everything an object* and make application "mashups" from simpler primitives that relate to that data in all the ways users want, much like unix commands did w/pipes. (-Python, +GPL/POSIX)
4. The *network is the computer* (Sun Microsystems), so integrate P2P architecture directly in the OS and make a data/app ecosystem.  (-Javascript, -file hierarchies)
5.  All objects exist in a UnifiedDataModel, so all apps draw on these objects re-useing them in many ways.  Each app primitive is inspectable.  There are no proprietary apps.  (+GPL)
6. *3D cyberspace visualization* to navigate the 4D hierarchy.  'Nuff said.  (+Pangaia/GlassBeadGame Project)

Good architeture can reduce your code base 100-fold.  The actual formula is some asymptote to 100*log2(LOC).  That's a huge savings that pays many dividends, like easier maintainance (as the code is architected to embody the problem domain more naturally, rather than artificial CS optimizations), better performance, more participants (because your code is actually understandable without a programming team's mini domain languages).

User I/O, Storage, Networking, and Processing form the high-level components of the system and the wiki has pages for each.  Go there for DesignGoals as well.

This OS will implement the material in "Gospel of Object-Oriented Programming" apt wiki.hackerspaces.org.  That is, objects are both data AND applications in a Unified Object Model (you can pronounce it "yum").  Files are objects, apps are objects, data are objects.  Finally realizing the design goals of OOP:  modularity (maintainability), encapsulation (data security), scalability (compositing), and object reuse (p2p networked re-use).  The internet produces exabytes of data, if the "network is the computer", we should have a data ecossytem for it rather than monolithic silos isolated from other data, kind of like multiprocessing, but for DATA.  Recognizing that data is growing faster than code, this project will experiment with many new ideas such as "LanguageAsAnOS", and "EverythignIsAnObject", trying new language ideas that facilitate such concepts.

As the OS will implement a unified epistemic model of data to knowledge, this project may merge with the GlassBeadGame at sourceforge.net.  It is called SINGULARITY, after all.  

All files are STUBS.  Fuck me and actually get some files with code in them.

Keywords: Blue Abyss, Reconfigurable OS, ...

.



