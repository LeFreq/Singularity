This is a project for the OS and lanugage CONVERGENCE, where OSs and languages figure out they're all trying to accomplish the same thing:  make computers do interesting things, persistently and efficiently (from both user and machine-view).  Turns out there's not that many significantly differnt ways to do that.  So, we're going to optimize it and do it perfectly with a language we'll call Prime (even though it may start as Python or some such available language).

It combines the best of programming language (Python/Forth/C/C++/ASM and others), using new computer science to measure programming language efficiency to make the BEST computer language (given a few caveats).  It emerged out of the conflict between proprietary and free software over which is best and the Mage Wars of the 21st Century over political correctness.  We'll combine the best practices of each and add totally NEW computer science.  For example, there's no compiler.  Parametized object macros are built from a perfected computer language that turns into machine code when objects are run.  OOP was the best architectural aid that CS had up to this point, but this project takes a systems-level approach and rearchitects the whole software environment, optimizing all OS-APP-HARDWARE questions so that every object is an app and every app is an object so components can be re-used.  

Imagine a networked, p2p software development environment where every object holds your paypal account which gets paid every time your object is run.  Now Free software programmers can be paid for being smart!  Software-encoded contracts and/or doctests keep everyone satisfied.

This is a project for the OS CONVERGENCE, where OSs figure out they're all trying to accomplish the same thing.  It emerged out of the conflict between proprietary and free software over which is best and the Mage Wars of the 21st Century over political correctness.  We'll combine the best practices of each and add totally NEW computer science.  For example, there's no compiler.  Parametized object macros are built from a perfected computer language that turns into machine code when objects are run.  OOP was the best architectural aid that CS had up to this point, but this project takes a systems-level approach and rearchitects the whole software environment, optimizing all OS-APP-HARDWARE questions so that every object is an app and every app is an object so components can be re-used.  
XXXThis. doc has gotten. corrupted.
Position creates a new OS starting from basic principles of OS theory, modular and object-oriented, and at the bare metal (the CPU architecture).  It comes out of frustration of the bloatware that all modern OSs have become and new wisdom about system architecture via epistemology (see Zen Code on the Pangaia wiki).  With no thanks to artificially cheap manufacturing prices and other voodoo, this project is made also to fix the instabilities that have cropped up from poor or inadequate design choices from legacy systems, including Intel, X, Microsoft, and Unix.  But we're not just going to scratch an itch, we're going to ADVANCE Computer Science and Philosophy.  Woot!

The name Position is a spin on POSIX.  The idea of PositionOS is Portability to the MAX, an end-point to those design goals.  See Samurai Jack (Pangaia wiki) for his contributions to these project ideas.  It is also architected like the human mind:  built from simple primitives towards higher levels of abstraction.

Core philosophies:
1. There are *two core relationships* to the machine as far as software and the OS are concerned:  application user and data administrator, much like CODE vs. DATA.  Hiding this from the user makes either users or developers dumb. (-ChromeOS/Surface/Windows10)
2. One can get better performance by using *better hardware and software archictecture* rather than requiring MORE hardware. (-Linux/Microsoft/Apple)
3. All data relate to other data (wikiwikiweb), so *make everything an object* and make application "mashups" from simpler primitives that relate to that data in all the ways users want, much like unix commands did w/pipes. (-Python, +GPL/POSIX)
4. The *network is the computer* (Sun Microsystems), so integrate P2P architecture directly in the OS and make a data/app ecosystem.  (-Javascript, -file hierarchies)
5.  All objects exist in a UnifiedDataModel, so all apps draw on these objects re-useing them in many ways.  Each app primitive is inspectable.  There are no proprietary apps.  (+GPL)
6. *3D cyberspace visualization* to navigate the 4D hierarchy.  'Nuff said.  (+Pangaia/GlassBeadGame Project)

Good architeture can reduce your code base 100-fold.  The actual formula is some asymptote to 100*log2(LOC).  That's a huge savings that pays many dividends, like easier maintainance (as the code is architected to embody the problem domain more naturally, rather than artificial CS optimizations), better performance, more participants (because your code is actually understandable without a programming team's mini domain languages).

User I/O, Storage, Networking, and Processing form the high-level components of the system and the wiki has pages for each.  Go there for DesignGoals as well.

This OS will implement the material in "Gospel of Object-Oriented Programming" apt wiki.hackerspaces.org.  That is, objects are both data AND applications in a Unified Object Model (you can pronounce it "yum").  Files are objects, apps are objects, data are objects.  Finally realizing the design goals of OOP:  modularity (maintainability), encapsulation (data security), scalability (compositing), and object reuse (p2p networked re-use).  The internet produces exabytes of data, if the "network is the computer", we should have a data ecossytem for it rather than monolithic silos isolated from other data, kind of like multiprocessing, but for DATA.  Recognizing that data is growing faster than code, this project will experiment with many new ideas such as "LanguageAsAnOS", and "EverythignIsAnObject", trying new language ideas that facilitate such concepts.

As the OS will implement a unified epistemic model of data to knowledge, this project may merge with the GlassBeadGame at sourceforge.net.  It is called SINGULARITY, after all.  

All files are STUBS.  Contact me and actually get some files with code in them.

Keywords: Blue Abyss, Reconfigurable OS, ...

.



